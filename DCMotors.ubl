module 'DCMotors'
author 'Russell Owen'
version 0 12
description 'Drive DC motors with encoders'
depends PID
variables motors__encoder_position _dcmotors__initialized _dcmotors__num_motors _dcmotors__max_speed _dcmotors__pin_duty_cycle _dcmotors__pin_encoder_a _dcmotors__pin_encoder_b _dcmotors__pin_direction _dcmotors__prev_encoder_a_state _dcmotors__prev_encoder_b_state _dcmotors__target_start_position _dcmotors__target_speed _dcmotors__target_start_msec _dcmotors__target_duration_msec _dcmotors__p_coeff _dcmotors__i_coeff _dcmotors__d_coeff _dcmotors__deadband _dcmotors__min_effort _dcmotors__max_effort _dcmotors__max_integral

  spec ' ' '_init_dcmotors_library' '_init_dcmotors_library'
  spec ' ' '_init_dcmotors_variables' '_init_dcmotors_variables'
  spec ' ' 'monitor_encoders' 'monitor motor encoders'
  spec ' ' 'drive_motors_to_follow_target' 'drive motors to follow target'
  spec ' ' 'reset_motor_encoder' 'reset motor encoder index _' 'num' 1
  spec ' ' 'move_motor_with_effort' 'move motor _ with effort _ (-1023 to 1023)' 'num num' 1 250
  spec ' ' 'move_motor_distance_speed' 'move motor _ distance _ (encoder counts) at speed _ (counts/sec)' 'num num num' 1 585 1000
  spec ' ' 'stop_all_motors' 'stop all motors'
  spec ' ' 'stop_motor' 'stop motor _' 'num' 1
  spec 'r' '_get_target_position_and_speed' 'get target position and speed for motor _ at time _ (msec, -1 for now)' 'num num' 1 -1
  spec ' ' '_basic_move_motor_with_effort' '_basic_move_motor_with_effort index _ effort _ (-1023 to 1023)' 'num num' 1 250

to _init_dcmotors_library {
  comment 'Initialize the DC Motors library.
Check motor power and initialize variables (if not already initialized).
Defaults to an XRP robot kit with 2 motors; change this code for other systems'
    if (not _dcmotors__initialized) {
        _dcmotors__num_motors = (get_num_motors)
        if (_dcmotors__num_motors == 0) {
            sayIt 'Error: get_num_motors is not defined, or is defined but returned 0'
            return
        }
        _init_dcmotors_variables
        _init_dcmotors_system_variables
        _dcmotors__initialized = (booleanConstant true)
    }
    _dcmotors_check_system
    sendBroadcast 'monitor_encoders'
    sendBroadcast 'drive_motors_to_follow_target'
}

to _init_dcmotors_variables {
    comment 'Initialize variables whose values do not depend on the type of system,
and create all lists (but do not set values) of variables that are system-specific.'
    motors__encoder_position = (newList _dcmotors__num_motors 0)
    _dcmotors__target_start_position = (newList _dcmotors__num_motors 0)
    _dcmotors__target_speed = (newList _dcmotors__num_motors 0)
    _dcmotors__target_start_msec = (newList _dcmotors__num_motors -1)
    _dcmotors__target_duration_msec = (newList _dcmotors__num_motors 0)
    _dcmotors__prev_encoder_a_state = (newList _dcmotors__num_motors (booleanConstant false))
    _dcmotors__prev_encoder_b_state = (newList _dcmotors__num_motors (booleanConstant false))
    comment 'The following lists are system specific, so their elements must be set elsewhere.'
    _dcmotors__pin_encoder_a = (newList _dcmotors__num_motors 0)
    _dcmotors__pin_encoder_b = (newList _dcmotors__num_motors 0)
    _dcmotors__pin_direction = (newList _dcmotors__num_motors 0)
    _dcmotors__pin_duty_cycle = (newList _dcmotors__num_motors 0)
}

to monitor_encoders {
    comment 'Monitor the motor encoders.
    This is a background tasks (and an infinite loop) which must be running in order for the remaining code
    to know where the wheels are.
    The encoders are assumed to be quadrature incremental encoders.
    Here is an explanation for how this code works:
    https://howtomechatronics.com/tutorials/arduino/rotary-encoder-works-use-arduino/'
    _init_dcmotors_library
    local 'encoder_a_state' (booleanConstant false)
    local 'encoder_b_state' (booleanConstant false)
    local 'prev_encoder_a_state' (booleanConstant false)
    local 'prev_encoder_b_state' (booleanConstant false)
    forever {
        for i _dcmotors__num_motors {
            encoder_a_state = (digitalReadOp (at i _dcmotors__pin_encoder_a))
            encoder_b_state = (digitalReadOp (at i _dcmotors__pin_encoder_b))
            prev_encoder_a_state = (at i _dcmotors__prev_encoder_a_state)
            prev_encoder_b_state = (at i _dcmotors__prev_encoder_b_state)
            if (encoder_a_state != prev_encoder_a_state) {
                atPut i _dcmotors__prev_encoder_a_state encoder_a_state
                if (encoder_a_state == encoder_b_state) {
                    atPut i motors__encoder_position ((at i motors__encoder_position) - 1)
                } else {
                    atPut i motors__encoder_position ((at i motors__encoder_position) + 1)
                }
            } (encoder_b_state != prev_encoder_b_state) {
                atPut i _dcmotors__prev_encoder_b_state encoder_b_state
                if (encoder_a_state == encoder_b_state) {
                    atPut i motors__encoder_position ((at i motors__encoder_position) + 1)
                } else {
                    atPut i motors__encoder_position ((at i motors__encoder_position) - 1)
                }
            }
        }
    }
}

to drive_motors_to_follow_target {
    comment 'Drive motors to follow the specified target position and speed.
This is a background task (infinite loop) that must be running in order for move_motor_distance_speed to work.'
    for i _dcmotors__num_motors {
        reset_pid i
    }
    _init_dcmotors_library
    local 'target_position_and_speed' 0
    local 'target_position' 0
    local 'target_speed' 0
    local 'encoder_position' 0
    local 'position_error' 0
    local 'correction' 0
    local 'effort' 0
    local 'raw_effort' 0
    forever {
        for i _dcmotors__num_motors {
            if ((at i _dcmotors__target_start_msec) >= 0) {
                target_position_and_speed = (_get_target_position_and_speed i -1)
                target_position = (at 1 target_position_and_speed)
                target_speed = (at 2 target_position_and_speed)
                encoder_position = (at i motors__encoder_position)
                comment 'Note: simple subtraction handles encoder wraparound automatically'
                position_error = (encoder_position - target_position)
                correction = (compute_pid i position_error _dcmotors__p_coeff _dcmotors__i_coeff _dcmotors__d_coeff _dcmotors__max_integral)
                comment 'Compute open loop predicted effort'
                effort = ((target_speed * _dcmotors__max_effort) / _dcmotors__max_speed)
                if ((absoluteValue effort) < _dcmotors__max_effort) {
                    effort = 0
                }
                effort += (correction / 1000)
                raw_effort = effort
                effort = (constrain_value effort _dcmotors__deadband _dcmotors__min_effort _dcmotors__max_effort)
                printIt position_error effort raw_effort
                comment 'Check that following is still wanted, just before commanding the motor.'
                if ((at i _dcmotors__target_start_msec) >= 0) {
                    _basic_move_motor_with_effort i effort
                }
            }
        }
    }
}

to reset_motor_encoder index {
    _init_dcmotors_library
    atPut index motors__encoder_position 0
}

to move_motor_with_effort index effort {
    comment 'Move the specified motor at the specified "effort", a value between -1023 and 1023.
Effort is the duty cycle of the drive signal to the motor (plus a sign signal),
and is roughly proportional to speed, at least if the motor has no load.
Warning:  geared motors have enough friction that they may not reliably move at low speeds.
For example the XRP wheels may not reliably move if the absolute value of effort is less than about 200.
This the usable range is rather small.'
    _init_dcmotors_library
    _basic_move_motor_with_effort index effort
}

to move_motor_distance_speed index distance speed {
    comment 'Move the specified motor by the specified amount (encoder counts) at the specified speed (counts/sec).
To move backwards, specify a negative distance.
Negating speed has no effect (this block always uses the absolute value of speed).
Warning: speed must not be 0.'
    if (speed == 0) {
        sayIt 'Error: speed must be nonzero'
        return
    }
    _init_dcmotors_library
    local 'duration_msec' (((absoluteValue distance) * 1000) / speed)
    comment 'Always start by setting time <0, set all other parameters, then set the real time.
This avoids race conditions.'
    speed = (absoluteValue speed)
    atPut index _dcmotors__target_start_msec -1
    atPut index _dcmotors__target_start_position (at index motors__encoder_position)
    atPut index _dcmotors__target_speed (apply_sign distance speed)
    atPut index _dcmotors__target_duration_msec duration_msec
    atPut index _dcmotors__target_start_msec (millisOp)
}

to stop_all_motors {
    for i _dcmotors__num_motors {
        stop_motor i
    }
}

to stop_motor index {
    _init_dcmotors_library
    atPut index _dcmotors__target_start_msec -1
    atPut index _dcmotors__target_speed 0
    analogWriteOp (at index _dcmotors__pin_duty_cycle) 0
}

to _get_target_position_and_speed index at_msec {
    comment 'Compute the target position for the specified motor at the specified time (msec, <0 for now).
Return a list with two elements:
* target position (encoder counts)
* target speed (encoder counts/second).
Assumes that _init_dcmotors_library has been called.'
    if (at_msec < 0) {
        at_msec = (millisOp)
    }
    local 'target_start_msec' (at index _dcmotors__target_start_msec)
    if (target_start_msec < 0) {
        sayIt 'Warning: no target; returning 0, 0'
        return ('[data:makeList]' 0 0)
    }
    local 'duration_msec' (elapsed_time target_start_msec at_msec)
    local 'target_duration_msec' (at index _dcmotors__target_duration_msec)
    local 'target_speed' 0
    if (duration_msec > target_duration_msec) {
        comment 'Move is done; target position = end position'
        duration_msec = target_duration_msec
        target_speed = 0
    } else {
        target_speed = (at index _dcmotors__target_speed)
    }
    local 'target_position' ((at index _dcmotors__target_start_position) + ((duration_msec * (at index _dcmotors__target_speed)) / 1000))
    return  ('[data:makeList]' target_position target_speed)
}

to _basic_move_motor_with_effort index effort {
    comment 'Implement move_motor_with_effort. Assumes that _init_dcmotors_library has been called'
    analogWriteOp (at index _dcmotors__pin_duty_cycle) (absoluteValue effort)
    digitalWriteOp (at index _dcmotors__pin_direction) (effort > 0)
}
