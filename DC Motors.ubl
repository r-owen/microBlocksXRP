module 'DC Motors'
author Russell Owen
version 0 1 \
description 'Drive DC motors with encoders'
variables left_motor_encoder right_motor_encoder _motors__initialized _motors_left_index _motors_right_index _motors__pin_duty_cycle _motors__pin_encoder_a _motors__pin_encoder_b _motors__pin_direction _xrp_pin_motor_R_Enable _xrp_pin_motor_R_EncoderA _xrp_pin_motor_R_EncoderB _xrp_pin_motor_R_Phase _xrp_pin_VIN_measure

  spec ' ' 'stop_motor' 'stop motor index _' 'num' 1
  spec ' ' 'stop_all_motors' 'stop all motors'
  spec ' ' 'set_motor_effort' 'set motor effort index _ effort _ (-1023 to 1023)' 'num num' 1 250
  spec ' ' 'motor effort' 'motor effort _ _ (-1023 to 1023)' 'num num' 250 250
  spec ' ' 'XRP Power check' 'XRP Power check'
  spec 'r' 'XRP VIN' 'XRP VIN'
  spec ' ' 'init' 'init'
  spec ' ' 'init_xrp' 'init xrp'
  spec ' ' 'monitor_left_motor_encoder' 'monitor_left_motor_encoder'
  spec ' ' 'monitor_right_motor_encoder' 'monitor_right_motor_encoder'

to stop_motor index {
  analogWriteOp (at index _motors__pin_duty_cycle) 0
}

to stop_all_motors {
  for i (size _motors__pin_duty_cycle) {
      stop_motor i
  }
}

to set_motor_effort index effort {
  'init'
  'XRP Power check'
  if else {
    analogWriteOp (at index _motors__pin_duty_cycle) (absoluteValue effort)
    digitalWriteOp (at index _motors__pin_direction) (effort > 0)
  }
}

to 'XRP Power check' {
  comment 'Check to see that power to the board is on
Suggest a change required for this script.'
  if (('XRP VIN') < 300) {
    sayIt 'Switch the XRP power to ON'
    waitUntil (('XRP VIN') > 300)
  }
}

to 'XRP VIN' {
  'init'
  return (analogReadOp _xrp_pin_VIN_measure)
}

to 'init' {
  init_xrp
}

to 'init_xrp' {
  if _motors__initialized {return}

  _motors_left_index = 1
  _motors_right_index = 2

  _motors__pin_encoder_a = (newList 4)
  _motors__pin_encoder_b = (newList 4)
  _motors__pin_direction = (newList 4)
  _motors__pin_duty_cycle = (newList 4)

  atPut 1 _motors__pin_encoder_a 4
  atPut 1 _motors__pin_encoder_b 5
  atPut 1 _motors__pin_direction 6
  atPut 1 _motors__pin_duty_cycle 7

  atPut 2 _motors__pin_encoder_a 12
  atPut 2 _motors__pin_encoder_b 13
  atPut 2 _motors__pin_direction 14
  atPut 2 _motors__pin_duty_cycle 15

  atPut 3 _motors__pin_encoder_a 0
  atPut 3 _motors__pin_encoder_b 1
  atPut 3 _motors__pin_direction 2
  atPut 3 _motors__pin_duty_cycle 3

  atPut 4 _motors__pin_encoder_a 8
  atPut 4 _motors__pin_encoder_b 9
  atPut 4 _motors__pin_direction 10
  atPut 4 _motors__pin_duty_cycle 11

  _xrp_pin_motor_R_EncoderA = 12
  _xrp_pin_motor_R_EncoderB = 13
  _xrp_pin_motor_R_Enable = 15
  _xrp_pin_motor_R_Phase = 14

  _xrp_pin_VIN_measure = 28
  _motors__initialized = (booleanConstant true)

}

to monitor_left_motor_encoder {
  comment 'Algorithm for counting steps and direction for Arduino.
https://howtomechatronics.com/tutorials/arduino/rotary-encoder-works-use-arduino/'
  'init'
  local 'aState' 0
  local 'aLastState' (digitalReadOp _motors__pin_encoder_a)
  forever {
    aState = (digitalReadOp _motors__pin_encoder_a)
    if (aState != aLastState) {
      if ((digitalReadOp _motors__pin_encoder_b) != aState) {
        left_motor_encoder += 1
      } else {
        left_motor_encoder += -1
      }
    }
    aLastState = aState
  }
}


to monitor_right_motor_encoder {
  comment 'Algorithm for counting steps and direction for Arduino.
https://howtomechatronics.com/tutorials/arduino/rotary-encoder-works-use-arduino/'
  'init'
  local 'aState' 0
  local 'aLastState' (digitalReadOp _xrp_pin_motor_R_EncoderA)
  forever {
    aState = (digitalReadOp _xrp_pin_motor_R_EncoderA)
    if (aState != aLastState) {
      if ((digitalReadOp _xrp_pin_motor_R_EncoderB) != aState) {
        right_motor_encoder += 1
      } else {
        right_motor_encoder += -1
      }
    }
    aLastState = aState
  }
}

to PID {
  local 'pvalue' 0
  local 'ivalue' 0
  local 'dvalue' 0
  local 'isum' 0
  local 'curr_error' 0
  local 'prev_error' 0
  curr_error = actual - desired
  pvalue = curr_error * p_coeff
  dvalue = (curr_error - prev_error) * d_coeff
  isum += curr_error
  ivalue = isum * i_coeff
  prev_error = curr_error
  return (pvalue + ivalue + dvalue)
}
