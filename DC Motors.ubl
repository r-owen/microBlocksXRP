module 'DC Motors'
author 'Russell Owen'
version 0 6
description 'Drive DC motors with encoders'
depends PID
variables motors__encoder_position _motors__num_motors _motors__max_speed _motors__pin_duty_cycle _motors__pin_encoder_a _motors__pin_encoder_b _motors__pin_direction _xrp_pin_input_voltage _motors__prev_encoder_a_state _motors__do_follow _motors__target_position _motors__p_coeff _motors__i_coeff _motors__d_coeff _motors__min_effort _motors__deadband _motors__max_integral

  spec ' ' 'init' 'init'
  spec ' ' '_init_common_variables' '_init_common_variables num_motors _' 'num' 2
  spec ' ' '_xrp_check_input_voltage' '_xrp_check_input_voltage'
  spec ' ' '_xrp_init_variables' '_xrp_init_variables num_motors _' 'num' 2
  spec ' ' 'monitor_encoders' 'monitor motor encoders'
  spec ' ' 'drive_motors_to_follow_target_position' 'drive motors to follow target position'
  spec ' ' 'reset_motor_encoder' 'reset motor encoder index _' 'num' 1
  spec ' ' 'move_at_effort' 'move motor _ with effort _ (-1023 to 1023)' 'num num' 1 250
  spec ' ' 'move_motor_by_amount' 'move motor _ by amount _ (encoder counts)' 'num num' 1 585
  spec ' ' 'move_motor_to_position' 'move motor _ to position _ (encoder counts)' 'num num' 1 585
  spec ' ' 'stop_all_motors' 'stop all motors'
  spec ' ' 'stop_motor' 'stop motor _' 'num' 1
  spec ' ' '_basic_move_at_effort' '_basic_move_at_effort index _ effort _ (-1023 to 1023)' 'num num' 1 250

to init {
  comment 'Check motor power and initialize variables (if not already initialized).
Defaults to an XRP robot kit with 2 motors; change this code for other systems'
    local 'num_motors' 2
    if (_motors__num_motors != num_motors) {
        _init_common_variables num_motors
        _xrp_init_variables num_motors
        _motors__num_motors = num_motors
    }
    _xrp_check_input_voltage
}

to _init_common_variables num_motors {
    comment 'Initialize variables whose values do not depend on the type of system'
    motors__encoder_position = (newList num_motors 0)
    _motors__do_follow = (newList num_motors (booleanConstant false))
    _motors__target_position = (newList num_motors 0)
}

to '_xrp_check_input_voltage' {
    comment 'Check to see that the board has motor power and say something if not.'
    repeatUntil ((analogReadOp _xrp_pin_input_voltage) >= 300) {
        sayIt 'Insufficient motor voltage; check the power switch and batteries.'
    }
    sayIt ''
}

to '_xrp_init_variables' num_motors {
    if ((num_motors < 2) or (num_motors > 4)) {
        sayIt 'Number of motors must be 2-4'
        return
    }
    _motors__p_coeff = 5000
    _motors__i_coeff = 0
    _motors__d_coeff = 0
    _motors__min_effort = 200
    _motors__deadband = 10
    _motors__max_integral = 10
    comment 'Approximate maximum motor speed (encoder counts/second) with no load'
    _motors__max_speed = 1080
    _motors__pin_encoder_a = (newList num_motors 0)
    _motors__pin_encoder_b = (newList num_motors 0)
    _motors__pin_direction = (newList num_motors 0)
    _motors__pin_duty_cycle = (newList num_motors 0)
    _motors__prev_encoder_a_state = (newList num_motors (booleanConstant false))
    atPut 1 _motors__pin_encoder_a 4
    atPut 1 _motors__pin_encoder_b 5
    atPut 1 _motors__pin_direction 6
    atPut 1 _motors__pin_duty_cycle 7
    atPut 2 _motors__pin_encoder_a 12
    atPut 2 _motors__pin_encoder_b 13
    atPut 2 _motors__pin_direction 14
    atPut 2 _motors__pin_duty_cycle 15
    if (num_motors > 2) {
        atPut 3 _motors__pin_encoder_a 0
        atPut 3 _motors__pin_encoder_b 1
        atPut 3 _motors__pin_direction 2
        atPut 3 _motors__pin_duty_cycle 3
    }
    if (num_motors > 3) {
        atPut 4 _motors__pin_encoder_a 8
        atPut 4 _motors__pin_encoder_b 9
        atPut 4 _motors__pin_direction 10
        atPut 4 _motors__pin_duty_cycle 11
    }
    _xrp_pin_input_voltage = 28
}

to monitor_encoders {
    comment 'Monitor the motor encoders.
    This must be called once to start monitoring, at which point it keeps running
    until the system is stopped.
    The encoders are assumed to be quadrature incremental encoders.
    Here is an explanation for how this code works:
    https://howtomechatronics.com/tutorials/arduino/rotary-encoder-works-use-arduino/'
    init
    local 'encoder_a_state' (booleanConstant false)
    local 'encoder_b_state' (booleanConstant false)
    local 'prev_encoder_a_state' (booleanConstant false)
    forever {
        for i _motors__num_motors {
            encoder_a_state = (digitalReadOp (at i _motors__pin_encoder_a))
            encoder_b_state = (digitalReadOp (at i _motors__pin_encoder_b))
            prev_encoder_a_state = (at i _motors__prev_encoder_a_state)
            if (encoder_a_state != prev_encoder_a_state) {
                atPut i _motors__prev_encoder_a_state encoder_a_state
                if (encoder_a_state == encoder_b_state) {
                atPut i motors__encoder_position ((at i motors__encoder_position) - 1)
                } else {
                atPut i motors__encoder_position ((at i motors__encoder_position) + 1)
                }
            }
        }
    }
}

to drive_motors_to_follow_target_position {
    for i _motors__num_motors {
        reset_pid i
    }
    init
    local 'target_speed' 0
    local 'encoder_position' 0
    local 'error' 0
    local 'correction' 0
    local 'effort' 0
    local 'raw_effort' 0
    local 'curr_time' 0
    forever {
        for i _motors__num_motors {
            target_position = (at i _motors__target_position)
            encoder_position = (at i motors__encoder_position)
            curr_time = (microsOp)
            if (at i _motors__do_follow) {
                comment 'Note: simple subtraction handles encoder wraparound automatically'
                error = (encoder_position - target_position)
                correction = (compute_pid i error _motors__p_coeff _motors__i_coeff _motors__d_coeff _motors__max_integral)
                effort = (correction / 1000)
                raw_effort = effort
                if ((absoluteValue effort) <= _motors__deadband) {
                    effort = 0
                } (effort > 1023) {
                    effort = 1023
                } (effort < -1024) {
                    effort = -1024
                } ((absoluteValue effort) < _motors__min_effort) {
                    if (effort < 0) {
                        effort = (-1 * _motors__min_effort)
                    } else {
                        effort = _motors__min_effort
                    }
                }
                printIt error effort raw_effort
                comment 'Check that following is still wanted, just before commanding the motor.'
                if (at i _motors__do_follow) {
                    _basic_move_at_effort i effort
                }
            }
        }
    }
}

to reset_motor_encoder index {
    init
    atPut index motors__encoder_position 0
}

to move_at_effort index effort {
    init
    _basic_move_at_effort index effort
}

to move_motor_by_amount index amount {
    comment 'Move the specified motor by the specified amount (in encoder counts).'
    init
    move_motor_to_position index ((at index motors__encoder_position) + amount)
}

to move_motor_to_position index position {
  comment 'Move the specified motor to the specified position (in encoder counts).
This simply sets the motor target position and enables following (if not already enabled);
for the motor to actually move, the drive_motors_to_follow_target_position block must be running.'
    init
    atPut index _motors__target_position position
    atPut index _motors__do_follow (booleanConstant true)
}

to stop_all_motors {
    for i _motors__num_motors {
        stop_motor i
    }
}

to stop_motor index {
    init
    atPut index _motors__do_follow (booleanConstant false)
    analogWriteOp (at index _motors__pin_duty_cycle) 0
}

to _basic_move_at_effort index effort {
    comment 'Implement move_at_effort, assuming init has been called'
    analogWriteOp (at index _motors__pin_duty_cycle) (absoluteValue effort)
    digitalWriteOp (at index _motors__pin_direction) (effort > 0)
}
