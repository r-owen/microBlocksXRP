module 'DC Motors'
author Russell
version 0 2
description 'Drive DC motors with encoders'
variables motors__encoder_counts _motors__num_motors _motors_left_index _motors_right_index _motors_encoder_threshold _motors__pin_duty_cycle _motors__pin_encoder_a _motors__pin_encoder_b _motors__pin_direction _xrp_pin_input_voltage _motors__prev_encoder_a_state 

  spec ' ' 'init' 'init'
  spec ' ' 'init_xrp' 'init xrp num_motors _' 'num' 2
  spec ' ' 'monitor_motor_encoders' 'monitor motor encoders'
  spec ' ' 'reset_motor_encoder' 'reset motor encoder index _' 'num' 1
  spec ' ' 'set_motor_effort' 'set motor effort index _ effort _ (-1023 to 1023)' 'num num' 1 250
  spec ' ' 'stop_all_motors' 'stop all motors'
  spec ' ' 'stop_motor' 'stop motor index _' 'num' 1
  spec ' ' '_xrp_check_input_voltage' '_xrp_check_input_voltage'
  spec ' ' '_xrp_init_variables' '_xrp_init_variables num_motors _' 'num' 2

to '_xrp_check_input_voltage' {
  comment 'Check to see that the board has motor power and say something if not.'
  if ((analogReadOp _xrp_pin_input_voltage) < 300) {
    sayIt 'Insufficient motor voltage; check the power switch and batteries.'
    waitUntil ((analogReadOp _xrp_pin_input_voltage) < 300)
  }
}

to '_xrp_init_variables' num_motors {
  if (_motors__num_motors == num_motors) {return}
  if nil {
    sayIt 'Number of motors must be 2-4'
    return
  }
  _motors_left_index = 1
  _motors_right_index = 2
  motors__encoder_counts = (newList num_motors 0)
  _motors__pin_encoder_a = (newList num_motors 0)
  _motors__pin_encoder_b = (newList num_motors 0)
  _motors__pin_direction = (newList num_motors 0)
  _motors__pin_duty_cycle = (newList num_motors 0)
  _motors__prev_encoder_a_state = (newList num_motors (booleanConstant false))
  atPut 1 _motors__pin_encoder_a 4
  atPut 1 _motors__pin_encoder_b 5
  atPut 1 _motors__pin_direction 6
  atPut 1 _motors__pin_duty_cycle 7
  atPut 2 _motors__pin_encoder_a 12
  atPut 2 _motors__pin_encoder_b 13
  atPut 2 _motors__pin_direction 14
  atPut 2 _motors__pin_duty_cycle 15
  if (num_motors > 2) {
    atPut 3 _motors__pin_encoder_a 0
    atPut 3 _motors__pin_encoder_b 1
    atPut 3 _motors__pin_direction 2
    atPut 3 _motors__pin_duty_cycle 3
  }
  if (num_motors > 3) {
    atPut 4 _motors__pin_encoder_a 8
    atPut 4 _motors__pin_encoder_b 9
    atPut 4 _motors__pin_direction 10
    atPut 4 _motors__pin_duty_cycle 11
  }
  _xrp_pin_input_voltage = 28
  _motors__num_motors = num_motors
}

to init {
  comment 'By default assumes an XRP robot kit with 2 motors.
  Modify if you have a different motor kit.'
  init_xrp 2
}

to init_xrp num_motors {
  '_xrp_init_variables' num_motors
  '_xrp_check_input_voltage'
}

to monitor_motor_encoders {
  comment 'Monitor the motor encoders.
  This must be called once to start monitoring, at which point it keeps running
  until the system is stopped.
  The encoders are assumed to be quadrature incremental encoders.
  Here is an explanation for how this code works:
  https://howtomechatronics.com/tutorials/arduino/rotary-encoder-works-use-arduino/'
  init
  local 'encoder_a_state' (booleanConstant false)
  local 'encoder_b_state' (booleanConstant false)
  local 'prev_encoder_a_state' (booleanConstant false)
  forever {
    for i _motors__num_motors {
      encoder_a_state = (digitalReadOp (at i _motors__pin_encoder_a))
      encoder_b_state = (digitalReadOp (at i _motors__pin_encoder_b))
      prev_encoder_a_state = (at i _motors__prev_encoder_a_state)
      if (encoder_a_state != prev_encoder_a_state) {
        if (encoder_a_state == encoder_b_state) {
          atPut i motors__encoder_counts ((at i motors__encoder_counts) - 1)
        } else {
          atPut i motors__encoder_counts ((at i motors__encoder_counts) + 1)
        }
      }
    }
  }
}

to reset_motor_encoder index {
    init
    atPut index motors__encoder_counts 0
}

to set_motor_effort index effort {
  init
  if else {
    analogWriteOp (at index _motors__pin_duty_cycle) (absoluteValue effort)
    digitalWriteOp (at index _motors__pin_direction) (effort > 0)
  }
}

to stop_all_motors {
  for i _motors__num_motors {
    stop_motor i
  }
}

to stop_motor index {
  init
  analogWriteOp (at index _motors__pin_duty_cycle) 0
}

