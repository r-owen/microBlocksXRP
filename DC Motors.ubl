module 'DC Motors'
author 'Russell Owen'
version 0 8
description 'Drive DC motors with encoders'
depends PID
variables motors__encoder_position _dcm__initialized _dcm__num_motors _dcm__max_speed _dcm__pin_duty_cycle _dcm__pin_encoder_a _dcm__pin_encoder_b _dcm__pin_direction _dcm__prev_encoder_a_state _dcm__target_time _dcm__target_position _dcm__target_speed _dcm__p_coeff _dcm__i_coeff _dcm__d_coeff _dcm__deadband _dcm__min_effort _dcm__max_effort _dcm__max_integral

  spec ' ' '_init_dcm_library' '_init_dcm_library'
  spec ' ' '_init_dcm_variables' '_init_dcm_variables'
  spec ' ' '_init_xrp_variables' '_init_xrp_variables'
  spec ' ' '_check_xrp_drive_voltage' '_check_xrp_drive_voltage'
  spec ' ' 'monitor_encoders' 'monitor motor encoders'
  spec ' ' 'drive_motors_to_follow_target_position' 'drive motors to follow target position'
  spec ' ' 'reset_motor_encoder' 'reset motor encoder index _' 'num' 1
  spec ' ' 'move_at_effort' 'move motor _ with effort _ (-1023 to 1023)' 'num num' 1 250
  spec ' ' 'move_motor_by_amount' 'move motor _ by amount _ (encoder counts)' 'num num' 1 585
  spec ' ' 'move_motor_to_position' 'move motor _ to position _ (encoder counts)' 'num num' 1 585
  spec ' ' 'set_motor_speed' 'set motor _ speed _ (encoder counts/sec)' 'num num' 1 0
  spec ' ' 'set_motor_target' 'set motor _ target position _  (encoder counts) speed _  (encoder counts/sec) time _ (milliseconds, now if <0)' 'num num num num' 1 0 0 -1
  spec ' ' 'stop_all_motors' 'stop all motors'
  spec ' ' 'stop_motor' 'stop motor _' 'num' 1
  spec ' ' '_basic_move_at_effort' '_basic_move_at_effort index _ effort _ (-1023 to 1023)' 'num num' 1 250

to _init_dcm_library {
  comment 'Initialize the DC Motors library.
Check motor power and initialize variables (if not already initialized).
Defaults to an XRP robot kit with 2 motors; change this code for other systems'
    if (not _dcm__initialized) {
        _dcm__num_motors = 2
        _init_dcm_variables
        _init_xrp_variables
        _dcm__initialized = (booleanConstant true)
    }
    _check_xrp_drive_voltage
}

to _init_dcm_variables {
    comment 'Initialize variables whose values do not depend on the type of system,
and create all lists (but do not set values) of variables that are system-specific.'
    motors__encoder_position = (newList _dcm__num_motors 0)
    _dcm__target_time = (newList _dcm__num_motors -1)
    _dcm__target_position = (newList _dcm__num_motors 0)
    _dcm__target_speed = (newList _dcm__num_motors 0)
    _dcm__prev_encoder_a_state = (newList _dcm__num_motors (booleanConstant false))
    comment 'The following lists are system specific, so their elements must be set elsewhere.'
    _dcm__pin_encoder_a = (newList _dcm__num_motors 0)
    _dcm__pin_encoder_b = (newList _dcm__num_motors 0)
    _dcm__pin_direction = (newList _dcm__num_motors 0)
    _dcm__pin_duty_cycle = (newList _dcm__num_motors 0)
}

to '_check_xrp_drive_voltage' {
    comment 'Check the board's drive power'
    repeatUntil ((analogReadOp 28) >= 300) {
        sayIt 'Insufficient drive voltage; check the power switch and batteries.'
    }
    sayIt ''
}

to '_init_xrp_variables' {
    comment 'Set system-specific motors variables.
Assume that _init_dcm_variables has been called, so that all lists exist.'
    if ((_dcm__num_motors < 2) or (_dcm__num_motors > 4)) {
        sayIt 'Number of motors must be 2-4'
        return
    }
    _dcm__p_coeff = 5000
    _dcm__i_coeff = 0
    _dcm__d_coeff = 0
    _dcm__deadband = 10
    _dcm__min_effort = 200
    _dcm__max_effort = 1023
    _dcm__max_integral = 10
    comment 'Approximate maximum motor speed (encoder counts/second) with no load'
    _dcm__max_speed = 1080
    atPut 1 _dcm__pin_encoder_a 4
    atPut 1 _dcm__pin_encoder_b 5
    atPut 1 _dcm__pin_direction 6
    atPut 1 _dcm__pin_duty_cycle 7
    atPut 2 _dcm__pin_encoder_a 12
    atPut 2 _dcm__pin_encoder_b 13
    atPut 2 _dcm__pin_direction 14
    atPut 2 _dcm__pin_duty_cycle 15
    if (_dcm__num_motors > 2) {
        atPut 3 _dcm__pin_encoder_a 0
        atPut 3 _dcm__pin_encoder_b 1
        atPut 3 _dcm__pin_direction 2
        atPut 3 _dcm__pin_duty_cycle 3
    }
    if (_dcm__num_motors > 3) {
        atPut 4 _dcm__pin_encoder_a 8
        atPut 4 _dcm__pin_encoder_b 9
        atPut 4 _dcm__pin_direction 10
        atPut 4 _dcm__pin_duty_cycle 11
    }
}

to monitor_encoders {
    comment 'Monitor the motor encoders.
    This must be called once to start monitoring, at which point it keeps running
    until the system is stopped.
    The encoders are assumed to be quadrature incremental encoders.
    Here is an explanation for how this code works:
    https://howtomechatronics.com/tutorials/arduino/rotary-encoder-works-use-arduino/'
    _init_dcm_library
    local 'encoder_a_state' (booleanConstant false)
    local 'encoder_b_state' (booleanConstant false)
    local 'prev_encoder_a_state' (booleanConstant false)
    forever {
        for i _dcm__num_motors {
            encoder_a_state = (digitalReadOp (at i _dcm__pin_encoder_a))
            encoder_b_state = (digitalReadOp (at i _dcm__pin_encoder_b))
            prev_encoder_a_state = (at i _dcm__prev_encoder_a_state)
            if (encoder_a_state != prev_encoder_a_state) {
                atPut i _dcm__prev_encoder_a_state encoder_a_state
                if (encoder_a_state == encoder_b_state) {
                atPut i motors__encoder_position ((at i motors__encoder_position) - 1)
                } else {
                atPut i motors__encoder_position ((at i motors__encoder_position) + 1)
                }
            }
        }
    }
}

to drive_motors_to_follow_target_position {
    for i _dcm__num_motors {
        reset_pid i
    }
    _init_dcm_library
    local 'target_time' -1
    local 'target_speed' 0
    local 'encoder_position' 0
    local 'position_error' 0
    local 'correction' 0
    local 'effort' 0
    local 'raw_effort' 0
    local 'delta_time' 0
    local 'delta_position' 0
    forever {
        for i _dcm__num_motors {
            target_time = (at i _dcm__target_time)
            if (target_time >= 0) {
                delta_time = (elapsed_time target_time (millisOp))
                delta_position = ((delta_time * (at i _dcm__target_speed)) / 1000)
                target_position = ((at i _dcm__target_position) + delta_position)
                encoder_position = (at i motors__encoder_position)
                comment 'Note: simple subtraction handles encoder wraparound automatically'
                position_error = (encoder_position - target_position)
                correction = (compute_pid i position_error _dcm__p_coeff _dcm__i_coeff _dcm__d_coeff _dcm__max_integral)
                effort = (correction / 1000)
                raw_effort = effort
                effort = (constrain_value effort _dcm__deadband _dcm__min_effort _dcm__max_effort)
                printIt target_position position_error effort raw_effort
                comment 'Check that following is still wanted, just before commanding the motor.'
                if ((at i _dcm__target_time) >= 0) {
                    _basic_move_at_effort i effort
                }
            }
        }
    }
}

to reset_motor_encoder index {
    _init_dcm_library
    atPut index motors__encoder_position 0
}

to move_at_effort index effort {
    _init_dcm_library
    _basic_move_at_effort index effort
}

to move_motor_by_amount index amount {
    comment 'Move the specified motor by the specified amount (in encoder counts).'
    _init_dcm_library
    set_motor_target index ((at index motors__encoder_position) + amount) 0 -1
}

to move_motor_to_position index position {
  comment 'Move the specified motor to the specified position (in encoder counts).
This simply sets the motor target position and enables following (if not already enabled);
for the motor to actually move, the drive_motors_to_follow_target_position block must be running.'
    _init_dcm_library
    set_motor_target index position 0 -1
}

to set_motor_speed index speed {
    comment 'Move the specified motor at the specified speed'
    _init_dcm_library
    set_motor_target index (at index motors__encoder_position) speed -1
}

to set_motor_target index position speed time {
    _init_dcm_library
    if (time < 0) {
        time = (millisOp)
    }
    comment 'Always start by setting time < 0, then speed = 0, to make race conflicts less problematic'
    atPut index _dcm__target_time -1
    atPut index _dcm__target_speed 0
    atPut index _dcm__target_position position
    atPut index _dcm__target_speed speed
    atPut index _dcm__target_time time
}

to stop_all_motors {
    for i _dcm__num_motors {
        stop_motor i
    }
}

to stop_motor index {
    _init_dcm_library
    atPut index _dcm__target_time -1
    atPut index _dcm__target_speed 0
    analogWriteOp (at index _dcm__pin_duty_cycle) 0
}

to _basic_move_at_effort index effort {
    comment 'Implement move_at_effort, assuming _init_dcm_library has been called'
    analogWriteOp (at index _dcm__pin_duty_cycle) (absoluteValue effort)
    digitalWriteOp (at index _dcm__pin_direction) (effort > 0)
}
