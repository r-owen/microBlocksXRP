module 'DC Motors'
author Russell
version 0 3
description 'Drive DC motors with encoders'
depends PID
variables motors__encoder_counts _motors__max_speed _motors__num_motors _motors__left_index _motors__right_index _motors__encoder_threshold _motors__pin_duty_cycle _motors__pin_encoder_a _motors__pin_encoder_b _motors__pin_direction _xrp_pin_input_voltage _motors__prev_encoder_a_state _motors__do_follow _motors__target_speed _motors__prev_follow_time _motors__prev_encoder_counts _motors__prev_effort _motors__p_coeff _motors__i_coeff _motors__d_coeff

  spec ' ' 'init' 'init'
  spec ' ' '_init_common_variables' '_init_common_variables num_motors _' 'num' 2
  spec ' ' 'init_xrp' 'init xrp num_motors _' 'num' 2
  spec ' ' 'monitor_motor_encoders' 'monitor motor encoders'
  spec ' ' 'motors_follow_target_speed' 'motors follow target speed'
  spec ' ' 'reset_motor_encoder' 'reset motor encoder index _' 'num' 1
  spec ' ' 'set_motor_effort' 'set motor effort index _ effort _ (-1023 to 1023)' 'num num' 1 250
  spec ' ' 'set_motor_target_speed' 'set motor target speed index _ speed _ (encoder counts/sec)' 'num num' 1 500
  spec ' ' 'stop_all_motors' 'stop all motors'
  spec ' ' 'stop_motor' 'stop motor index _' 'num' 1
  spec ' ' '_xrp_check_input_voltage' '_xrp_check_input_voltage'
  spec ' ' '_xrp_init_variables' '_xrp_init_variables num_motors _' 'num' 2

to '_xrp_check_input_voltage' {
  comment 'Check to see that the board has motor power and say something if not.'
  while ((analogReadOp _xrp_pin_input_voltage) < 300) {
    sayIt 'Insufficient motor voltage; check the power switch and batteries.'
  }
  sayIt ''
}

to '_xrp_init_variables' num_motors {
  if (_motors__num_motors == num_motors) {return}
  if ((num_motors < 2) or (num_motors > 4)) {
    sayIt 'Number of motors must be 2-4'
    return
  }
  _motors__left_index = 1
  _motors__right_index = 2
  comment 'Approximate maximum motor speed (encoder counts/second) with no load'
  _motors__max_speed = 1080
  _motors__pin_encoder_a = (newList num_motors 0)
  _motors__pin_encoder_b = (newList num_motors 0)
  _motors__pin_direction = (newList num_motors 0)
  _motors__pin_duty_cycle = (newList num_motors 0)
  _motors__prev_encoder_a_state = (newList num_motors (booleanConstant false))
  atPut 1 _motors__pin_encoder_a 4
  atPut 1 _motors__pin_encoder_b 5
  atPut 1 _motors__pin_direction 6
  atPut 1 _motors__pin_duty_cycle 7
  atPut 2 _motors__pin_encoder_a 12
  atPut 2 _motors__pin_encoder_b 13
  atPut 2 _motors__pin_direction 14
  atPut 2 _motors__pin_duty_cycle 15
  if (num_motors > 2) {
    atPut 3 _motors__pin_encoder_a 0
    atPut 3 _motors__pin_encoder_b 1
    atPut 3 _motors__pin_direction 2
    atPut 3 _motors__pin_duty_cycle 3
  }
  if (num_motors > 3) {
    atPut 4 _motors__pin_encoder_a 8
    atPut 4 _motors__pin_encoder_b 9
    atPut 4 _motors__pin_direction 10
    atPut 4 _motors__pin_duty_cycle 11
  }
  _xrp_pin_input_voltage = 28
}

to init {
  comment 'By default assumes an XRP robot kit with 2 motors.
  Modify if you have a different motor kit.'
  init_xrp 2
}

to _init_common_variables num_motors {
  if (_motors__num_motors == num_motors) {return}
  motors__encoder_counts = (newList num_motors 0)
  _motors__do_follow = (newList num_motors (booleanConstant false))
  _motors__target_speed = (newList num_motors 0)
  _motors__prev_follow_time = (newList num_motors -1)
  _motors__prev_encoder_counts = (newList num_motors 0)
  _motors__prev_effort = (newList num_motors 0)
  _motors__p_coeff = 1
  _motors__i_coeff = 0
  _motors__d_coeff = 0
}

to init_xrp num_motors {
  _init_common_variables num_motors
  _xrp_init_variables num_motors
  _xrp_check_input_voltage
  _motors__num_motors = num_motors
}

to monitor_motor_encoders {
  comment 'Monitor the motor encoders.
  This must be called once to start monitoring, at which point it keeps running
  until the system is stopped.
  The encoders are assumed to be quadrature incremental encoders.
  Here is an explanation for how this code works:
  https://howtomechatronics.com/tutorials/arduino/rotary-encoder-works-use-arduino/'
  init
  local 'encoder_a_state' (booleanConstant false)
  local 'encoder_b_state' (booleanConstant false)
  local 'prev_encoder_a_state' (booleanConstant false)
  forever {
    for i _motors__num_motors {
      encoder_a_state = (digitalReadOp (at i _motors__pin_encoder_a))
      encoder_b_state = (digitalReadOp (at i _motors__pin_encoder_b))
      prev_encoder_a_state = (at i _motors__prev_encoder_a_state)
      if (encoder_a_state != prev_encoder_a_state) {
        atPut i _motors__prev_encoder_a_state encoder_a_state
        if (encoder_a_state == encoder_b_state) {
          atPut i motors__encoder_counts ((at i motors__encoder_counts) - 1)
        } else {
          atPut i motors__encoder_counts ((at i motors__encoder_counts) + 1)
        }
      }
    }
  }
}

to motors_follow_target_speed {
    for i _motors__num_motors {
        reset_pid i
    }
    init
    local target_speed 0
    local encoder_counts 0
    local meas_speed 0
    local error 0
    local correction 0
    local effort 0
    local curr_time 0
    local prev_time 0
    local prev_effort 0
    local prev_encoder_counts 0
    local prev_effort 0
    forever {
      for i _motors__num_motors {
        target_speed = (at i _motors__target_speed)
        encoder_counts = (at i motors__encoder_counts)
        curr_time = (microsOp)
        prev_time = (at i _motors__prev_follow_time)
        prev_effort = (at i _motors__prev_effort)
        prev_encoder_counts = (at i _motors__prev_encoder_counts)
        if (at i _motors__do_follow) {
            if (prev_time >= 0) {
                comment 'Update to handle encoder wraparound'
                meas_speed = (((encoder_counts - prev_encoder_counts) * 1000000) / (elapsed_microseconds prev_time curr_time))
                error = (meas_speed - target_speed)
                correction = (compute_pid i error _motors__p_coeff _motors__i_coeff _motors__d_coeff)
                effort = (prev_effort + (correction / 10))
            } else {
                 effort = ((1023 * target_speed) / _motors__max_speed)
            }
            set_motor_effort i effort
            atPut i _motors__prev_follow_time curr_time
            atPut i _motors__prev_effort effort
            atPut i _motors__prev_encoder_counts encoder_counts
        }
      }
    }
}

to reset_motor_encoder index {
    init
    atPut index motors__encoder_counts 0
}

to set_motor_effort index effort {
  init
  analogWriteOp (at index _motors__pin_duty_cycle) (absoluteValue effort)
  digitalWriteOp (at index _motors__pin_direction) (effort > 0)
}

to set_motor_target_speed index speed {
  comment 'Set the motor target speed and enable following (if not already enabled)'
  init
  atPut index _motors__target_speed speed
  atPut index _motors__do_follow (booleanConstant true)
}

to stop_all_motors {
  for i _motors__num_motors {
    stop_motor i
  }
}

to stop_motor index {
  init
  atPut index _motors__do_follow (booleanConstant false)
  analogWriteOp (at index _motors__pin_duty_cycle) 0
}
