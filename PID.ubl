module 'PID'
author 'Russell Owen'
version 0 7
description 'PID Control Loop'
variables _pid__initialized _pid__prev_error _pid__prev_time _pid__prev_integral 

  spec ' ' '_extend_pid_lists' '_extend pid lists; index _' 'num' 1
  spec ' ' '_init_pid_library' '_init_pid_library'
  spec 'r' 'apply_sign' 'apply sign _ to value _' 'num num' 1 0
  spec 'r' 'constrain_value' 'constrain value _ deadband _ minimum _ maximum _' 'num num num num' 0 0 0 1000
  spec 'r' 'elapsed_time' 'elapsed_time start_time _ end_time _' 'num num' 0 0
  spec 'r' 'compute_pid' 'compute pid at index _ error _ p coeff _ i coeff _ d coeff _ max integral _ (ignored if 0)' 'num num num num num num' 1 0 1 0 0 0
  spec ' ' 'reset_pid' 'reset pid at index _' 'num' 1

to _extend_pid_lists index {
  comment 'Extend the global lists used for PID computations,
if needed, so that they are large enough to use the specified index.
This must be called by every public block.'
  _init_pid_library
  repeatUntil ((size _pid__prev_error) >= index) {
    '[data:addLast]' 0 _pid__prev_error
    '[data:addLast]' -1 _pid__prev_time
    '[data:addLast]' 0 _pid__prev_integral
  }
}

to _init_pid_library {
  comment 'Create global lists. Must be called by every public block,
  but that can be accomplished by calling _extend_pid_lists.'
  if (not _pid__initialized) {
    _pid__prev_error = (newList 0)
    _pid__prev_time = (newList 0)
    _pid__prev_integral = (newList 0)
    _pid__initialized = (booleanConstant true)
  }
}

to apply_sign sign value {
    comment 'If sign < 0 return -value else return value'
    if (sign < 0) {
        return (-1 * value)
    } else {
        return value
    }
}

to constrain_value value deadband minimum maximum {
    comment 'Constrain a value as follows:
If |value| < deadband: return 0.
If |value| < minimum: return minimum with sign of value.
If |value| > maximum: return maximum with sign of value.'
    local abs_value (absoluteValue value)
    if (abs_value < deadband) {
        return 0
    } (abs_value < minimum) {
        return (apply_sign value minimum)
    } (abs_value > maximum) {
        return (apply_sign value maximum)
    } else {
        return value
    }
}

to compute_pid index error p_coeff i_coeff d_coeff max_integral {
  comment 'Compute the next PID value value, using inputs:
* index: index of the PID loop
* error: error to correct
* p_coeff: proportional coefficient (corr/error)
* i_coeff: integral coefficient (corr-msec/error)
* d_coeff: derivitive coefficient (corr/error-msec)
* max_integral: maximum absolute value of the integrated error; ignored if 0'
  _extend_pid_lists index
  local 'p_value' 0
  local 'i_value' 0
  local 'd_value' 0
  local 'integral' 0
  local 'curr_time' (microsOp)
  local 'prev_time' (at index _pid__prev_time)
  p_value = (p_coeff * error)
  if (prev_time >= 0) {
    comment 'We have old data for this PID loop, so compute derivitive and integral contributions.'
    local 'delta_time' (elapsed_time prev_time curr_time)
    local 'diff_error' (error - (at index _pid__prev_error))
    d_value = (((d_coeff * diff_error) * 1000) / delta_time)
    integral = (((error * delta_time) / 1000) + (at index _pid__prev_integral))
    if (and (max_integral > 0) ((absoluteValue max_integral) > max_integral)) {
        integral = (apply_sign integral max_integral)
    }
    i_value = (i_coeff * integral)
  }
  atPut index _pid__prev_time curr_time
  atPut index _pid__prev_error error
  atPut index _pid__prev_integral integral
  return (-1 * (p_value + (i_value + d_value)))
}

to elapsed_time start_time end_time {
  comment 'Safely compute an elapsed time from two microsecond or millisecond clock values,  
taking into account the fact that the clocks wrap from 1073741823 to 0.
Warning: requires prerelease firmware for milliseconds; the millisecond clock in release firmware wraps at a smaller value.'
  local 'delta_time' (end_time - start_time)
  if (delta_time < 0) {
    delta_time += -1073741824
  }
  return delta_time
}

to reset_pid index {
  comment 'Zero the recorded error data for a specific PID loop.
Call this before starting each move, to avoid unwanted values
from the integral and derivitive terms.'
  _extend_pid_lists index
  atPut index _pid__prev_error 0
  atPut index _pid__prev_time -1
  atPut index _pid__prev_integral 0
}

